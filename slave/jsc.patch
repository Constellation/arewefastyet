Index: jsc.cpp
===================================================================
--- jsc.cpp	(revision 205393)
+++ jsc.cpp	(working copy)
@@ -40,6 +40,7 @@
 #include "JIT.h"
 #include "JSArray.h"
 #include "JSArrayBuffer.h"
+#include "JSArrayBufferConstructor.h"
 #include "JSCInlines.h"
 #include "JSFunction.h"
 #include "JSInternalPromise.h"
@@ -600,6 +601,7 @@
 static EncodedJSValue JSC_HOST_CALL functionLoad(ExecState*);
 static EncodedJSValue JSC_HOST_CALL functionLoadString(ExecState*);
 static EncodedJSValue JSC_HOST_CALL functionReadFile(ExecState*);
+static EncodedJSValue JSC_HOST_CALL functionReadBinaryFile(ExecState*);
 static EncodedJSValue JSC_HOST_CALL functionCheckSyntax(ExecState*);
 static EncodedJSValue JSC_HOST_CALL functionReadline(ExecState*);
 static EncodedJSValue JSC_HOST_CALL functionPreciseTime(ExecState*);
@@ -801,6 +803,7 @@
         addFunction(vm, "load", functionLoad, 1);
         addFunction(vm, "loadString", functionLoadString, 1);
         addFunction(vm, "readFile", functionReadFile, 1);
+        addFunction(vm, "readBinaryFile", functionReadBinaryFile, 1);
         addFunction(vm, "checkSyntax", functionCheckSyntax, 1);
         addFunction(vm, "jscStack", functionJSCStack, 1);
         addFunction(vm, "readline", functionReadline, 0);
@@ -1552,6 +1555,29 @@
     return JSValue::encode(jsString(exec, stringFromUTF(script)));
 }
 
+EncodedJSValue JSC_HOST_CALL functionReadBinaryFile(ExecState* exec)
+{
+    VM& vm = exec->vm();
+    auto scope = DECLARE_THROW_SCOPE(vm);
+
+    String fileName = exec->argument(0).toString(exec)->value(exec);
+    Vector<char> script;
+    if (!fillBufferWithContentsOfFile(fileName, script))
+        return JSValue::encode(throwException(exec, scope, createError(exec, ASCIILiteral("Could not open file."))));
+
+    JSArrayBufferConstructor* constructor =
+        jsCast<JSArrayBufferConstructor*>(exec->callee());
+
+    RefPtr<ArrayBuffer> buffer = ArrayBuffer::create(script.data(), script.size());
+    if (!buffer)
+        return JSValue::encode(throwException(exec, scope, createError(exec, ASCIILiteral("Out of memory"))));
+    
+    JSArrayBuffer* result = JSArrayBuffer::create(
+        exec->vm(), constructor->globalObject()->arrayBufferStructure(), buffer);
+    
+    return JSValue::encode(result);
+}
+
 EncodedJSValue JSC_HOST_CALL functionCheckSyntax(ExecState* exec)
 {
     VM& vm = exec->vm();
